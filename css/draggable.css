.is-dragging::before {
	content: '';
	position: absolute;
	top: -40%;
	left: -40%;
	right: -40%;
	bottom: -40%;
	/* background-color: rgba(255, 255, 255, 0.1); */
	background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path fill=\"rgba(0,0,0,0.3)\" d=\"M12 2l4 4h-3v4h-2V6h-3l4-4zm0 20l-4-4h3v-4h2v4h3l-4 4zm-10-10l4 4v-3h4v-2H6V8L2 12zm20 0l-4-4v3h-4v2h4v3l4-4z\"/></svg>');
	background-repeat: no-repeat;
	background-position: center center;
	background-size: contain;
	pointer-events: none;
	z-index: 2;
	overflow: visible;
	opacity: .5;
}

.is-dragging::after { 
    content: ''; 
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
 /*   border: 2px dashed red; */
    border-radius: inherit;
 position: absolute;
  
  /*  transform: scale(0.9) translateZ(0); */
   filter: blur(5px); 
	/*was 20, with opacity .75 */
 opacity:.8;
    background: linear-gradient(
      to left,
      red,
      orange,
      yellow,
      green,
      blue,
      #8800FF,
      #FF0088
    );
    background-size: 200% 200%;
   animation: animateGlow 1.25s linear infinite; 
	clip-path: polygon(-100% -100%, -100% 200%, -1% 200%, -1% -1%, 101% -1%, 101% 101%, -1% 101%, -1% 200%, 200% 200%, 200% -100%) 
  }


@keyframes animateGlow {
  0% {
    background-position: 0% 50%;
  }
  100% {
    background-position: 200% 50%;
  }

}

.is-dragging {
	  cursor: grabbing !important;
	/* border-width:2px; nah, causes content shifts on things without borders. We'll only do this if things already have a border. . */
/* border:inherit dashed  #777 !important; */
	  /* border-color:rgba(0,0,0,0) !important;hide borders, ::after element will draw them. this way drawing a border won't move the contents, whether or not there's already a border */
	

 
}
